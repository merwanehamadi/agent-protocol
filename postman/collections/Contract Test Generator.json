{
	"info": {
		"_postman_id": "2f154205-ee01-4411-9b82-a7f1f23b0f68",
		"name": "Contract Test Generator",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_uid": "28411126-2f154205-ee01-4411-9b82-a7f1f23b0f68"
	},
	"item": [
		{
			"name": "API Validation",
			"item": [
				{
					"name": "Cleanup Previous Run",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// See https://blog.postman.com/2019/05/28/pro-tip-dynamically-unset-postman-environment-variables/\r",
									"// for more details on what we're doing here. \r",
									"\r",
									"cleanupCollectionVariables();\r",
									"\r",
									"function cleanupCollectionVariables() {\r",
									"    const clean = _.keys(pm.collectionVariables.toObject());\r",
									"\r",
									"    _.each(clean, (arrItem) => {\r",
									"        pm.collectionVariables.unset(arrItem);\r",
									"    });\r",
									"}"
								],
								"type": "text/javascript",
								"id": "e7190a2b-cec3-488c-b066-b9ddcec9c480"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"id": "b69a6dca-f894-4831-8571-96186ef5e30b"
							}
						}
					],
					"id": "2ba40fed-2f73-4dc7-83de-56854021a278",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "https://postman-echo.com/delay/0",
							"protocol": "https",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"delay",
								"0"
							]
						}
					},
					"response": []
				},
				{
					"name": "Initialize",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const providedSchema = pm.environment.get('env-schema');\r",
									"if(providedSchema){\r",
									"    let success = true;\r",
									"    try{\r",
									"        const yaml = pm.environment.get('env-jsonToYaml');\r",
									"        (new Function(yaml))();\r",
									"\r",
									"        const schema = jsyaml.load(providedSchema);\r",
									"        pm.collectionVariables.set('coll-schema', JSON.stringify(schema));\r",
									"        postman.setNextRequest('Verify Component Adherence');\r",
									"    }\r",
									"    catch(err){\r",
									"        console.log(err);\r",
									"        success = false;\r",
									"        postman.setNextRequest(null);\r",
									"    }\r",
									"\r",
									"    pm.test('Successfully converted provided schema', function(){\r",
									"        pm.expect(success).to.be.true;\r",
									"    });    \r",
									"}"
								],
								"type": "text/javascript",
								"id": "5b443f8d-3ee8-4cb0-a14c-cadc9ab18b6a"
							}
						}
					],
					"id": "7fd6ca2f-30f0-4554-a45a-2b985e9513d9",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "https://postman-echo.com/delay/0",
							"protocol": "https",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"delay",
								"0"
							]
						}
					},
					"response": []
				},
				{
					"name": "Validate API In Workspace",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const minApiCount = Number(pm.environment.get('env-minApiCount'));\r",
									"const maxApiCount = Number(pm.environment.get('env-maxApiCount'));\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test(`Workspace API count is between ${minApiCount} and ${maxApiCount}. (Count: ${jsonData.apis.length})`, function () {    \r",
									"    pm.expect(jsonData.apis.length).to.be.at.least(minApiCount);    \r",
									"    pm.expect(jsonData.apis.length).to.be.at.most(maxApiCount);\r",
									"});\r",
									"\r",
									"let apiIds = [];\r",
									"_.forEach(jsonData.apis, function(api){\r",
									"    apiIds.push(api.id);\r",
									"});\r",
									"\r",
									"pm.collectionVariables.set('coll-apiIds', JSON.stringify(apiIds));"
								],
								"type": "text/javascript",
								"id": "e493342f-8a89-4a2e-ab81-8b2219503855"
							}
						}
					],
					"id": "710ef938-668a-429e-ae7d-9e8852e3039c",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "X-Api-Key",
								"value": "{{env-apiKey}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "https://api.getpostman.com/apis?workspace={{env-workspaceId}}",
							"protocol": "https",
							"host": [
								"api",
								"getpostman",
								"com"
							],
							"path": [
								"apis"
							],
							"query": [
								{
									"key": "workspace",
									"value": "{{env-workspaceId}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get Current API Version",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test('API has one or more versions', function(){\r",
									"    pm.expect(jsonData).to.have.property('versions').and.to.be.an('array');\r",
									"    pm.expect(jsonData.versions.length).to.be.above(0);\r",
									"});\r",
									"\r",
									"const version = jsonData.versions[0];\r",
									"pm.collectionVariables.set('coll-versionId', version.id);"
								],
								"type": "text/javascript",
								"id": "078dc49a-bb89-46ee-b0bc-a95f098ecf60"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"let apiIds = pm.collectionVariables.get('coll-apiIds');\r",
									"if(apiIds){\r",
									"    apiIds = JSON.parse(apiIds);\r",
									"    const apiId = apiIds.pop();\r",
									"\r",
									"    pm.collectionVariables.set('coll-apiId', apiId);\r",
									"    pm.collectionVariables.set('coll-apiIds', JSON.stringify(apiIds));\r",
									"}\r",
									"else {\r",
									"    pm.request.url = 'https://postman-echo.com/delay/0'\r",
									"    pm.request.name = 'No APIs found in the workspace. Skipping execution';\r",
									"    postman.setNextRequest(null);\r",
									"}"
								],
								"type": "text/javascript",
								"id": "8f0b05c6-a58c-496a-b021-ef05689cfbd1"
							}
						}
					],
					"id": "e933639d-081f-45d2-b174-c09e9790718d",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "X-Api-Key",
								"value": "{{env-apiKey}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "https://api.getpostman.com/apis/:apiId/versions",
							"protocol": "https",
							"host": [
								"api",
								"getpostman",
								"com"
							],
							"path": [
								"apis",
								":apiId",
								"versions"
							],
							"query": [
								{
									"key": null,
									"value": "",
									"disabled": true
								}
							],
							"variable": [
								{
									"key": "apiId",
									"value": "{{coll-apiId}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get Current API Schema",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test('Has schema for current version', function(){\r",
									"    pm.expect(jsonData).to.have.property('version');\r",
									"    pm.expect(jsonData.version).to.have.property('schema').and.to.be.an('array');\r",
									"    pm.expect(jsonData.version.schema.length).to.be.above(0);\r",
									"\r",
									"    pm.collectionVariables.set('coll-schemaId', jsonData.version.schema[0]);\r",
									"});"
								],
								"type": "text/javascript",
								"id": "fec0059b-10a6-4a10-a698-108bea3ef960"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"id": "c9531e4b-3682-4e10-851e-e0a3a5b3c59e"
							}
						}
					],
					"id": "b0d96bc3-051f-482d-8f29-95c09c6f58e2",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "X-Api-Key",
								"type": "text",
								"value": "{{env-apiKey}}"
							}
						],
						"url": {
							"raw": "https://api.getpostman.com/apis/:apiId/versions/:versionId",
							"protocol": "https",
							"host": [
								"api",
								"getpostman",
								"com"
							],
							"path": [
								"apis",
								":apiId",
								"versions",
								":versionId"
							],
							"query": [
								{
									"key": null,
									"value": "",
									"disabled": true
								}
							],
							"variable": [
								{
									"key": "apiId",
									"value": "{{coll-apiId}}"
								},
								{
									"key": "versionId",
									"value": "{{coll-versionId}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get Schema From URL",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "03426d60-5828-44a6-a7a9-1cc77698944a",
								"exec": [
									"let responseSchema = pm.response.text();",
									"",
									"if(responseSchema.length != 0) {",
									"    let success = true;",
									"    try{",
									"        const yaml = pm.environment.get('env-jsonToYaml');",
									"        (new Function(yaml))();",
									"",
									"        const schema = jsyaml.load(responseSchema);",
									"        pm.collectionVariables.set('coll-schema', JSON.stringify(schema));",
									"        postman.setNextRequest('Get API Base Url');",
									"    }",
									"    catch(err){",
									"        console.log(err);",
									"        success = false;",
									"        postman.setNextRequest(null);",
									"    }",
									"",
									"    pm.test('Successfully converted provided schema', function(){",
									"        pm.expect(success).to.be.true;",
									"    }); ",
									"} else {",
									"    console.log(\"Error retrieving schema from URL - \" + pm.environment.get(\"env-schemaUrl\"));",
									"    postman.setNextRequest(null);",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"id": "481e5d17-2465-4cea-a8db-156ed9d871bd",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{env-schemaUrl}}",
							"host": [
								"{{env-schemaUrl}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get API Base Url",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "ef0236a2-27d7-4598-9acb-ba6a778a3191",
								"exec": [
									"const schema = JSON.parse(pm.collectionVariables.get('coll-schema'));\r",
									"const server = pm.environment.get('env-server');\r",
									"\r",
									"pm.test('Environment has test server defined', function () {\r",
									"    pm.expect(server).to.not.be.undefined;\r",
									"});\r",
									"\r",
									"pm.test('Schema has server/baseUrl defined', function () {\r",
									"    const servers = schema.servers;\r",
									"    pm.expect(servers).to.not.be.undefined;\r",
									"    const serverToTest = servers.find(s => s.url.toLowerCase() == server.toLowerCase());\r",
									"    pm.expect(serverToTest).to.not.be.undefined;\r",
									"\r",
									"    pm.expect(serverToTest).to.have.property('url');\r",
									"    pm.collectionVariables.set('coll-baseUrl', serverToTest.url);\r",
									"});\r",
									"\r",
									"const runComponentTests = pm.environment.get('env-runComponentTests') == 'true';\r",
									"if(!runComponentTests){   \r",
									"    const runContractTests = pm.environment.get('env-runContractTests') == 'true';\r",
									"    if(runContractTests){\r",
									"        postman.setNextRequest('Build Schema Tests');\r",
									"    } else {\r",
									"        postman.setNextRequest('More APIs to Process?');\r",
									"    }   \r",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"id": "9f30546f-3666-4a35-a9f1-e3349902562f",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "https://postman-echo.com/delay/0",
							"protocol": "https",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"delay",
								"0"
							]
						}
					},
					"response": []
				}
			],
			"id": "0f73b186-2be0-432b-9e47-69c284afb163"
		},
		{
			"name": "Components",
			"item": [
				{
					"name": "Verify Component Adherence",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const schema = JSON.parse(pm.collectionVariables.get('coll-schema'));\r",
									"\r",
									"const requireParamDescription = Boolean(pm.environment.get('env-requireParamDescription'));\r",
									"const requireParamExample = Boolean(pm.environment.get('env-requireParamExample'));\r",
									"\r",
									"let paramDescriptionMinLength = pm.environment.get('env-paramDescriptionMinLength');\r",
									"if (paramDescriptionMinLength) {\r",
									"    paramDescriptionMinLength = Number(paramDescriptionMinLength);\r",
									"}\r",
									"\r",
									"let paramDescriptionMaxLength = pm.environment.get('env-paramDesciptionMaxLength');\r",
									"if (paramDescriptionMaxLength) {\r",
									"    paramDescriptionMaxLength = Number(paramDescriptionMaxLength);\r",
									"}\r",
									"\r",
									"var testedSchemaRefs = [];\r",
									"\r",
									"if (schema.components.parameters) {\r",
									"    for (let prop in schema.components.parameters) {\r",
									"        let parameter = schema.components.parameters[prop];\r",
									"\r",
									"        pm.test(`Parameter '${prop}' starts with a lowercase letter`, function () {\r",
									"            pm.expect(prop.charAt(0)).to.equal(prop.charAt(0).toLowerCase());\r",
									"        });\r",
									"\r",
									"        if (requireParamDescription) {\r",
									"            pm.test(`Parameter '${prop}' has a description between ${paramDescriptionMinLength} and ${paramDescriptionMaxLength} characters`, function () {\r",
									"                pm.expect(parameter).to.have.property('description').and.to.be.a('string');\r",
									"                pm.expect(parameter.description.length).to.be.at.least(paramDescriptionMinLength);\r",
									"                pm.expect(parameter.description.length).to.be.at.most(paramDescriptionMaxLength);\r",
									"            });\r",
									"        }\r",
									"\r",
									"        if (requireParamExample) {\r",
									"            pm.test(`Parameter '${prop}' has an example`, function () {\r",
									"                pm.expect(parameter).to.have.property('schema');\r",
									"                pm.expect(parameter.schema).to.have.property('example');\r",
									"            });\r",
									"        }\r",
									"    }\r",
									"}\r",
									"\r",
									"if (schema.components.schemas) {\r",
									"    for (let prop in schema.components.schemas) {\r",
									"        pm.test(`Schema '${prop}' begins with an uppercase letter`, function () {\r",
									"            pm.expect(prop.charAt(0)).to.equal(prop.charAt(0).toUpperCase());\r",
									"        });\r",
									"\r",
									"        const testedSchema = testedSchemaRefs.find(tsr => tsr == prop);\r",
									"        if (!testedSchema) {\r",
									"            const schemaObject = schema.components.schemas[prop];\r",
									"            testSchemaObject(schema, schemaObject, prop);\r",
									"            testedSchemaRefs.push(prop);\r",
									"        }\r",
									"    }\r",
									"}\r",
									"\r",
									"if (schema.components.responses) {\r",
									"    for (let prop in schema.components.responses) {\r",
									"        pm.test(`Response '${prop}' begins with an uppercase letter`, function () {\r",
									"            pm.expect(prop.charAt(0)).to.equal(prop.charAt(0).toUpperCase());\r",
									"        });\r",
									"\r",
									"        if (requireParamDescription) {\r",
									"            const response = schema.components.responses[prop];\r",
									"            pm.test(`Response '${prop}' has a description between ${paramDescriptionMinLength} and ${paramDescriptionMaxLength} characters`, function () {\r",
									"                pm.expect(response).to.have.property('description').and.to.be.a('string');\r",
									"                pm.expect(response.description.length).to.be.at.least(paramDescriptionMinLength);\r",
									"                pm.expect(response.description.length).to.be.at.most(paramDescriptionMaxLength);\r",
									"            });\r",
									"        }\r",
									"    }\r",
									"}\r",
									"\r",
									"const runContractTests = pm.environment.get('env-runContractTests') == 'true';\r",
									"if (runContractTests) {\r",
									"    postman.setNextRequest('Build Schema Tests');\r",
									"} else {\r",
									"    postman.setNextRequest('More APIs to Process?');\r",
									"}\r",
									"\r",
									"\r",
									"function testSchemaObject(schema, object, objectName) {\r",
									"    if (object.type && object.type.toLowerCase() == 'object') {\r",
									"        if (object.required) {\r",
									"            for (let i = 0; i < object.required.length; i++) {\r",
									"                const requiredProp = object.required[i];\r",
									"                pm.test(`Schema '${objectName}' has required property '${requiredProp}' defined`, function () {\r",
									"                    pm.expect(object.properties).to.have.property(requiredProp);\r",
									"                });\r",
									"            }\r",
									"        }\r",
									"\r",
									"        let schemaPropertyExceptions = [];\r",
									"        if (pm.environment.has('env-schemaPropertyExceptions')) {\r",
									"            schemaPropertyExceptions = JSON.parse(pm.environment.get('env-schemaPropertyExceptions'));\r",
									"        }\r",
									"\r",
									"        for (let prop in object.properties) {\r",
									"            const property = object.properties[prop];\r",
									"\r",
									"            if (!schemaPropertyExceptions.some(pe => pe === prop)) {\r",
									"                pm.test(`Schema property '${objectName}.${prop}' is lowercase`, function () {\r",
									"                    pm.expect(prop.charAt(0)).to.equal(prop.charAt(0).toLowerCase());\r",
									"                });\r",
									"            }\r",
									"\r",
									"            if (property.type && property.type.toLowerCase() == 'object') {\r",
									"                testSchemaObject(schema, property, `${objectName}.${prop}`);\r",
									"            }\r",
									"            else if (property.type && property.type.toLowerCase() == 'array') {\r",
									"                testSchemaObject(schema, property, `${objectName}.${prop}(list)`);\r",
									"            }\r",
									"            else if (property.oneOf) {\r",
									"                _.forEach(property.oneOf, (oneOf, i) => {\r",
									"                    testSchemaObject(schema, oneOf, `${objectName}.${prop}(oneOf).${i}`)\r",
									"                });\r",
									"            }\r",
									"            else if (property.allOf) {\r",
									"                _.forEach(property.allOf, (allOf, i) => {\r",
									"                    testSchemaObject(schema, allOf, `${objectName}.${prop}(allOf).${i}`)\r",
									"                });\r",
									"            }\r",
									"            else if (property.anyOf) {\r",
									"                _.forEach(property.anyOf, (anyOf, i) => {\r",
									"                    testSchemaObject(schema, anyOf, `${objectName}.${prop}(anyOf).${i}`)\r",
									"                });\r",
									"            }\r",
									"            else {\r",
									"                if (requireParamDescription && !property.$ref) {\r",
									"                    pm.test(`Schema property '${objectName}.${prop}' has a description between ${paramDescriptionMinLength} and ${paramDescriptionMaxLength} characters`, function () {\r",
									"                        pm.expect(property).to.have.property('description').and.to.be.a('string');\r",
									"                        pm.expect(property.description.length).to.be.at.least(paramDescriptionMinLength);\r",
									"                        pm.expect(property.description.length).to.be.at.most(paramDescriptionMaxLength);\r",
									"                    });\r",
									"\r",
									"                    if (property.description) {\r",
									"                        pm.test(`Schema property '${objectName}.${prop}' description is not just the name`, function () {\r",
									"                            pm.expect(prop.toLowerCase()).to.not.equal(property.description.toLowerCase());\r",
									"                        });\r",
									"                    }\r",
									"                }\r",
									"\r",
									"                if (requireParamExample && !property.$ref) {\r",
									"                    pm.test(`Schema property '${objectName}.${prop}' has an example`, function () {\r",
									"                        pm.expect(property).to.have.property('example');\r",
									"                    });\r",
									"                }\r",
									"            }\r",
									"        }\r",
									"    }\r",
									"    else if (object.type && object.type.toLowerCase() == 'array') {\r",
									"        pm.test(`Schema '${objectName}' has items defined`, function () {\r",
									"            pm.expect(object).to.have.property('items');\r",
									"        });\r",
									"\r",
									"        testSchemaObject(schema, object.items, `${objectName}.list`);\r",
									"    }\r",
									"    else if (object.oneOf) {\r",
									"        handleSchemaArray(schema, object, objectName, 'oneOf');\r",
									"    } else if (object.allOf) {\r",
									"        handleSchemaArray(schema, object, objectName, 'allOf');\r",
									"    }\r",
									"    else if (object.anyOf) {\r",
									"        handleSchemaArray(schema, object, objectName, 'anyOf');\r",
									"    }\r",
									"    else if (object.$ref) {\r",
									"        const name = getName(object.$ref);\r",
									"        const testedRef = testedSchemaRefs.find(tsr => tsr == name);\r",
									"        if (!testedRef) {\r",
									"            testSchemaObject(schema, schema.components.schemas[name], objectName);\r",
									"            testedSchemaRefs.push(name);\r",
									"        }\r",
									"    }\r",
									"    else {\r",
									"        pm.test(`Schema '${objectName}' has a declared type`, function () {\r",
									"            pm.expect(object).to.have.property('type');\r",
									"        });\r",
									"    }\r",
									"}\r",
									"\r",
									"function handleSchemaArray(schema, object, objectName, arrayType) {\r",
									"    for (let i = 0; i < object[arrayType].length; i++) {\r",
									"        const arraySchema = object[arrayType][i];\r",
									"        if (arraySchema.$ref) {\r",
									"            const name = getName(arraySchema.$ref);\r",
									"            const testedRef = testedSchemaRefs.find(tsr => tsr == name);\r",
									"            if (!testedRef) {\r",
									"                testSchemaObject(schema, schema.components.schemas[name], `${objectName}[${i}](ref ${name})`);\r",
									"                testedSchemaRefs.push(name);\r",
									"            }\r",
									"        }\r",
									"        else {\r",
									"            testSchemaObject(schema, arraySchema, `${objectName}[${i}]`);\r",
									"        }\r",
									"    }\r",
									"}\r",
									"\r",
									"function getName(ref) {\r",
									"    let pieces = ref.split('/');\r",
									"    return pieces[pieces.length - 1];\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"id": "e5434f85-a3c9-49a8-897f-619db873effb"
							}
						}
					],
					"id": "078ff7f5-31d0-4f94-94ff-f2859316fcc3",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "https://postman-echo.com/delay/0",
							"protocol": "https",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"delay",
								"0"
							]
						}
					},
					"response": []
				}
			],
			"id": "85c5d8d7-de26-42db-a993-b82c4e92b661"
		},
		{
			"name": "Contract Tests",
			"item": [
				{
					"name": "Build Schema Tests",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const schema = JSON.parse(pm.collectionVariables.get('coll-schema'));\r",
									"\r",
									"let schemaTests = [];\r",
									"for (let prop in schema.paths) {\r",
									"  const pathName = prop;\r",
									"  let path = {\r",
									"    path: `${pm.collectionVariables.get('coll-baseUrl')}${pathName}`,\r",
									"    parameters: schema.paths[prop].parameters,\r",
									"  };\r",
									"\r",
									"  for (let method in schema.paths[prop]) {\r",
									"    if (method.toLowerCase() == 'parameters' || isMockEndpoint(schema.paths[prop][method])) {\r",
									"      continue;\r",
									"    }\r",
									"\r",
									"    let currentPath = _.cloneDeep(path);\r",
									"    currentPath.method = method.toUpperCase();\r",
									"    let pathMethod = schema.paths[prop][method];\r",
									"    currentPath.parameters = combineParameters(currentPath.parameters, pathMethod.parameters);\r",
									"    let securityExtension = pm.environment.get('env-securityExtensionName');\r",
									"    if (securityExtension && pathMethod[securityExtension] && pathMethod[securityExtension].length > 0) {\r",
									"      currentPath.allowedRole = pathMethod[securityExtension][0];\r",
									"    }\r",
									"\r",
									"    const expectedResponses = getExpectedResponses(pathMethod);\r",
									"    currentPath.responses = expectedResponses;\r",
									"\r",
									"    if (pathMethod.requestBody) {\r",
									"      let bodyModel;\r",
									"      if (pathMethod.requestBody.content['application/json']?.schema?.$ref) {\r",
									"        bodyModel = getSchemaReference(schema, pathMethod.requestBody.content['application/json'].schema.$ref);\r",
									"      }\r",
									"      else if (pathMethod.requestBody.content['application/json']?.schema) {\r",
									"        bodyModel = pathMethod.requestBody.content['application/json'].schema;\r",
									"      }\r",
									"      else {\r",
									"        continue;\r",
									"      }\r",
									"\r",
									"      const models = buildModels(schema, bodyModel);\r",
									"      const mutations = buildModelMutations(models);\r",
									"\r",
									"      mutations.forEach((mutation) => {\r",
									"        let schemaTest = _.cloneDeep(currentPath);\r",
									"        Object.assign(schemaTest, mutation);\r",
									"        schemaTest.name = `${schemaTest.method} - ${pathName} - ${schemaTest.description} - SUCCESS: ${schemaTest.success}`;\r",
									"        schemaTests.push(schemaTest);\r",
									"      });\r",
									"    }\r",
									"    else {\r",
									"      currentPath.name = `${currentPath.method} - ${pathName} - No Request Body - SUCCESS: true`;\r",
									"      currentPath.success = true;\r",
									"      schemaTests.push(currentPath);\r",
									"    }\r",
									"  }\r",
									"}\r",
									"schemaTests = moveDeleteEndpointsToEnd(schemaTests);\r",
									"pm.collectionVariables.set('coll-schemaTests', JSON.stringify(schemaTests));\r",
									"\r",
									"// \r",
									"// Move delete endpoints to the end for cleanup\r",
									"//\r",
									"function moveDeleteEndpointsToEnd(schemaTests) {\r",
									"  let sortedTests = [...schemaTests];\r",
									"  try {\r",
									"    let successfulDeletes = sortedTests.filter(schemaTest => schemaTest.method == 'DELETE' && schemaTest.success);\r",
									"\r",
									"    if (successfulDeletes) {\r",
									"      // order deletes from the deepest entity to highest level entity based on path\r",
									"      successfulDeletes.sort((a, b) => b.path.split('/').length - a.path.split('/').length);\r",
									"      sortedTests = sortedTests.filter(schemaTest => !successfulDeletes.find(sd => sd == schemaTest));\r",
									"      sortedTests = sortedTests.concat(successfulDeletes);\r",
									"    }\r",
									"  }\r",
									"  catch (err) {\r",
									"    console.log('An error occurred when sorting delete tests', err);\r",
									"  }\r",
									"\r",
									"  return sortedTests;\r",
									"}\r",
									"\r",
									"//\r",
									"// Supporting Methods Below\r",
									"//\r",
									"function buildModels(schema, object) {\r",
									"  let models = [];\r",
									"\r",
									"  if (object['$ref']) {\r",
									"    object = getSchemaReference(schema, object['$ref']);\r",
									"  }\r",
									"\r",
									"  if (object.type && object.type.toLowerCase() == 'object') {\r",
									"    if (object.required && object.required.length > 0) {\r",
									"      models.push({});\r",
									"      _.forEach(object.required, function (param) {\r",
									"        const property = object.properties[param];\r",
									"\r",
									"        if (property.type && ['string', 'number', 'integer', 'boolean'].includes(property.type.toLowerCase())) {\r",
									"          for (let modelIndex = 0; modelIndex < models.length; modelIndex++) {\r",
									"            let model = models[modelIndex];\r",
									"            model[param] = property.example;\r",
									"          }\r",
									"        }\r",
									"        else {\r",
									"          const nestedObjects = buildModels(schema, property);\r",
									"          models = addToModels(models, nestedObjects, param);\r",
									"        }\r",
									"      });\r",
									"    }\r",
									"\r",
									"    if (object.minProperties) {\r",
									"      _.forEach(models, function (model) {\r",
									"        if (Object.keys(model).length < object.minProperties) {\r",
									"          for (let i = Object.keys(model).length; i < object.minProperties; i++) {\r",
									"            for (const [key, value] of Object.entries(object.properties)) {\r",
									"              if (['string', 'number', 'integer', 'boolean'].includes(value.type.toLowerCase()) && model[key] == undefined) {\r",
									"                model[key] = value.example;\r",
									"                break;\r",
									"              }\r",
									"            }\r",
									"          }\r",
									"        }\r",
									"      })\r",
									"    }\r",
									"  }\r",
									"  else if (object.type && object.type.toLowerCase() == 'array') {\r",
									"    let items = buildModels(schema, object.items);\r",
									"    if (Array.isArray(items)) {\r",
									"      for (let i = 0; i < items.length; i++) {\r",
									"        models.push([items[i]]);\r",
									"      }\r",
									"    }\r",
									"    else {\r",
									"      models.push([items]);\r",
									"    }\r",
									"  }\r",
									"  else if (object.oneOf) {\r",
									"    _.forEach(object.oneOf, function (component) {\r",
									"      let items = buildModels(schema, component);\r",
									"      models = models.concat(items);\r",
									"    });\r",
									"  }\r",
									"  else if (object.allOf) {\r",
									"    let pieces = [{}];\r",
									"    _.forEach(object.allOf, function (component) {\r",
									"      let componentModels = buildModels(schema, component);\r",
									"      pieces = addToModels(pieces, componentModels);\r",
									"    });\r",
									"\r",
									"    models = pieces;\r",
									"  }\r",
									"  else if (object.anyOf) {\r",
									"    let pieces = [];\r",
									"    let combinedPieces = [{}];\r",
									"    _.forEach(object.anyOf, function (component) {\r",
									"      let componentModels = buildModels(schema, component);\r",
									"      combinedPieces = addToModels(combinedPieces, componentModels);\r",
									"      pieces = pieces.concat(componentModels);\r",
									"    });\r",
									"\r",
									"    models = pieces.concat(combinedPieces);\r",
									"  }\r",
									"  else {\r",
									"    // All other options are primitive values\r",
									"    return object.example;\r",
									"  }\r",
									"  return models;\r",
									"}\r",
									"\r",
									"function getSchemaReference(schema, referenceName) {\r",
									"  const refPieces = referenceName.split('/');\r",
									"  let reference = schema;\r",
									"  for (let i = 1; i < refPieces.length; i++) {\r",
									"    reference = reference[refPieces[i]];\r",
									"  }\r",
									"\r",
									"  return reference;\r",
									"}\r",
									"\r",
									"function addToModels(models, newPieces, name) {\r",
									"  let newModels = [];\r",
									"  _.forEach(models, function (model) {\r",
									"    _.forEach(newPieces, function (newPiece) {\r",
									"      let newModel = _.cloneDeep(model);\r",
									"      if (name) {\r",
									"        newModel[name] = newPiece;\r",
									"      }\r",
									"      else {\r",
									"        Object.assign(newModel, newPiece);\r",
									"      }\r",
									"      newModels.push(newModel);\r",
									"    });\r",
									"  });\r",
									"\r",
									"  return newModels;\r",
									"}\r",
									"\r",
									"function buildModelMutations(models) {\r",
									"  let modelMutations = [];\r",
									"  _.forEach(models, function (model) {\r",
									"    addMutation(true, 'Has all required fields', model, modelMutations);\r",
									"    let mutations = buildMutation(model);\r",
									"    modelMutations = modelMutations.concat(mutations);\r",
									"  });\r",
									"\r",
									"  return modelMutations;\r",
									"}\r",
									"\r",
									"function buildMutation(model) {\r",
									"  let mutations = [];\r",
									"\r",
									"  for (const [key, value] of Object.entries(model)) {\r",
									"    if (typeof value == 'object') {\r",
									"      let nestedMutations = buildMutation(value);\r",
									"      nestedMutations.forEach((nestedMutation) => {\r",
									"        let mutation = _.cloneDeep(model);\r",
									"        mutation[key] = nestedMutation.body;\r",
									"        addMutation(false, `${nestedMutation.description} in ${key} object`, mutation, mutations);\r",
									"      });\r",
									"\r",
									"      let mutation = _.cloneDeep(model);\r",
									"      delete mutation[key];\r",
									"      addMutation(false, `Missing ${key} object`, mutation, mutations);\r",
									"\r",
									"      let emptyMutation = _.cloneDeep(model);\r",
									"      emptyMutation[key] = {};\r",
									"      addMutation(false, `Empty ${key} object`, emptyMutation, mutations);\r",
									"    }\r",
									"    else {\r",
									"      if (Array.isArray(value)) {\r",
									"        console.log('probably an error');\r",
									"      }\r",
									"      let mutation = _.cloneDeep(model);\r",
									"      delete mutation[key];\r",
									"      addMutation(false, `Missing ${key} property`, mutation, mutations);\r",
									"\r",
									"      let blankMutation = _.cloneDeep(model);\r",
									"      blankMutation[key] = '';\r",
									"      addMutation(false, `Blank ${key} property`, blankMutation, mutations);\r",
									"    }\r",
									"  }\r",
									"\r",
									"  return mutations;\r",
									"}\r",
									"\r",
									"function addMutation(isSuccess, description, mutation, mutations) {\r",
									"  mutations.push({\r",
									"    success: isSuccess,\r",
									"    description: description,\r",
									"    body: mutation\r",
									"  });\r",
									"}\r",
									"\r",
									"function getExpectedResponses(pathMethod) {\r",
									"  const responses = [];\r",
									"  for (const [statusCode, value] of Object.entries(pathMethod.responses)) {\r",
									"    let response = {\r",
									"      statusCode: Number(statusCode)\r",
									"    };\r",
									"\r",
									"    if (value['x-postman-variables'] && Array.isArray(value['x-postman-variables'])) {\r",
									"      response.variables = value['x-postman-variables'].filter(variable => variable.type.toLowerCase() === 'save');\r",
									"    }\r",
									"\r",
									"    if (value.$ref) {\r",
									"      response.$ref = value.$ref;\r",
									"    }\r",
									"    else {\r",
									"      if (value.content?.['application/json']?.schema) {\r",
									"        if (value.content['application/json'].schema.$ref) {\r",
									"          response.$ref = value.content['application/json'].schema.$ref;\r",
									"        }\r",
									"        else {\r",
									"          response.schema = value.content['application/json'].schema;\r",
									"        }\r",
									"      }\r",
									"    }\r",
									"\r",
									"    responses.push(response);\r",
									"  }\r",
									"  return responses;\r",
									"}\r",
									"\r",
									"function isMockEndpoint(pathMethod) {\r",
									"  let isMock = false;\r",
									"  if (pathMethod && pathMethod['x-amazon-apigateway-integration'] && pathMethod['x-amazon-apigateway-integration'].type\r",
									"    && pathMethod['x-amazon-apigateway-integration'].type.toLowerCase() == 'mock') {\r",
									"    isMock = true;\r",
									"  }\r",
									"\r",
									"  return isMock;\r",
									"}\r",
									"\r",
									"function combineParameters(endpointParameters, methodParameters) {\r",
									"  if (!endpointParameters && !methodParameters) {\r",
									"    return;\r",
									"  }\r",
									"  let parameters = [];\r",
									"  if (endpointParameters && endpointParameters.length) {\r",
									"    parameters = [...endpointParameters];\r",
									"  }\r",
									"\r",
									"  if (methodParameters && methodParameters.length) {\r",
									"    parameters = [...parameters, ...methodParameters];\r",
									"  }\r",
									"\r",
									"  return parameters;\r",
									"}"
								],
								"type": "text/javascript",
								"id": "f29f66e2-f2f9-4377-af51-fccd47a3af15"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"let schemaTests = pm.collectionVariables.get('coll-schemaTests');\r",
									"if(schemaTests){\r",
									"    schemaTests = JSON.parse(schemaTests);\r",
									"    if(!schemaTests || !schemaTests.length){\r",
									"        postman.setNextRequest('More APIs to Process?');\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript",
								"id": "7fc4644f-2f54-4a3d-b398-249d409027a9"
							}
						}
					],
					"id": "3e2254dd-71f5-4716-9a89-4627c8036a62",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "https://postman-echo.com/delay/0",
							"protocol": "https",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"delay",
								"0"
							]
						}
					},
					"response": []
				},
				{
					"name": "Test Request",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"id": "fb04a781-66c8-4c08-876e-bded3751b02c",
								"exec": [
									"const url = require('url');\r",
									"\r",
									"console.log('Fetching schema and schema tests...');\r",
									"const schema = JSON.parse(pm.collectionVariables.get('coll-schema'));\r",
									"let schemaTests = JSON.parse(pm.collectionVariables.get('coll-schemaTests'));\r",
									"console.log('Schema:', schema);\r",
									"console.log('Initial Schema Tests:', schemaTests);\r",
									"\r",
									"const schemaTest = schemaTests.shift();\r",
									"console.log('Current schemaTest:', schemaTest);\r",
									"\r",
									"pm.collectionVariables.set('coll-schemaTests', JSON.stringify(schemaTests));\r",
									"pm.variables.set('currentSchemaTest', JSON.stringify(schemaTest));\r",
									"\r",
									"const path = replacePathParameters(schema, schemaTest.path, schemaTest.parameters);\r",
									"console.log('Path after replacing parameters:', path);\r",
									"pm.request.url.update(path);\r",
									"\r",
									"delete pm.request.url.auth;\r",
									"delete pm.request.url.port;\r",
									"delete pm.request.url.hash;\r",
									"\r",
									"if (pm.request.url.protocol) {\r",
									"  pm.request.url.protocol = pm.request.url.protocol.replace(/\\:$/, '');\r",
									"} else {\r",
									"  pm.request.url.protocol = 'https';\r",
									"}\r",
									"\r",
									"pm.request.method = schemaTest.method;\r",
									"pm.request.name = schemaTest.name;\r",
									"console.log('Updated request:', pm.request);\r",
									"\r",
									"pm.variables.set('requestName', schemaTest.name);\r",
									"pm.variables.set('body', JSON.stringify(schemaTest.body));\r",
									"\r",
									"// Add top level parameters from the path\r",
									"const roleHeaderName = pm.environment.get('env-roleHeaderName');\r",
									"console.log('Role Header Name:', roleHeaderName);\r",
									"\r",
									"if (schemaTest.parameters) {\r",
									"  for (let i = 0; i < schemaTest.parameters.length; i++) {\r",
									"    let param = schemaTest.parameters[i];\r",
									"\r",
									"    if (param.$ref) {\r",
									"      let pieces = param.$ref.split('/');\r",
									"      const name = pieces[pieces.length - 1];\r",
									"      const schemaParam = schema.components.parameters[name];\r",
									"      const paramType = schemaParam.in.toLowerCase();\r",
									"      const paramValue = loadParameterValue(schemaParam);\r",
									"      if (paramType == 'header' && schemaParam.required == true) {\r",
									"        if (roleHeaderName && schemaParam.name.toLowerCase() == roleHeaderName.toLowerCase()) {\r",
									"          pm.request.headers.upsert({ key: schemaParam.name, value: schemaTest.allowedRole });\r",
									"        }\r",
									"        else {\r",
									"          pm.request.headers.upsert({ key: schemaParam.name, value: paramValue });\r",
									"        }\r",
									"      } else if (paramType == 'query' && schemaParam.required == true) {\r",
									"        pm.request.url.query.upsert({ key: schemaParam.name, value: paramValue });\r",
									"      }\r",
									"    } else {\r",
									"      const paramType = param.in.toLowerCase();\r",
									"      const paramValue = loadParameterValue(param);\r",
									"      if (paramType == 'header') {\r",
									"        pm.request.headers.upsert({ key: param.name, value: paramValue });\r",
									"      } else if (paramType == 'query' && param.required == true) {\r",
									"        pm.request.url.query.upsert({ key: param.name, value: paramValue });\r",
									"      }\r",
									"    }\r",
									"  }\r",
									"}\r",
									"\r",
									"function loadParameterValue(parameter) {\r",
									"  let parameterValue;\r",
									"  console.log('Loading parameter value for:', parameter);\r",
									"  if (parameter['x-postman-variables']) {\r",
									"    let variable = parameter['x-postman-variables'].find(v => v.type.toLowerCase() === 'load');\r",
									"    if (variable && pm.collectionVariables.has(variable.name)) {\r",
									"      parameterValue = pm.collectionVariables.get(variable.name);\r",
									"    } else {\r",
									"      parameterValue = resolveParameterExample(parameter);\r",
									"    }\r",
									"  } else {\r",
									"    parameterValue = resolveParameterExample(parameter);\r",
									"  }\r",
									"\r",
									"  console.log('Loaded value:', parameterValue);\r",
									"  return parameterValue;\r",
									"}\r",
									"\r",
									"function resolveParameterExample(parameter) {\r",
									"  console.log(\"resolveParameterExample:\", JSON.stringify(parameter));\r",
									"  let paramValue = (parameter.schema.example != undefined) ? parameter.schema.example : parameter.example;\r",
									"  let value = paramValue;\r",
									"  if (typeof paramValue !== 'number' && typeof paramValue !== 'boolean') {\r",
									"    let pathVariableRegex = /^{{\\$.*}}$/;\r",
									"    let matches = paramValue.match(pathVariableRegex);\r",
									"\r",
									"    if (matches && matches.length) {\r",
									"      value = pm.variables.replaceIn(paramValue);\r",
									"    }\r",
									"  }\r",
									"\r",
									"  console.log('Resolved parameter example value:', value);\r",
									"  return encodeURIComponent(value);\r",
									"}\r",
									"\r",
									"function replacePathParameters(schema, pathName, parameters) {\r",
									"  console.log('Replacing Path Parameters - Path:', pathName, 'Parameters:', parameters);\r",
									"  \r",
									"  let replacedPathName = pathName;\r",
									"  let pathVariableRegex = /{([^}]*)}/g;\r",
									"  let matches = pathName.match(pathVariableRegex);\r",
									"  _.forEach(matches, function (match) {\r",
									"    let paramName = match.substring(1, match.length - 1);\r",
									"    _.forEach(parameters, function (param) {\r",
									"      if (param.$ref) {\r",
									"        let parameter = getSchemaReference(schema, param.$ref);\r",
									"        if (parameter.in && parameter.in.toLowerCase() == 'path' && parameter.name && parameter.name == paramName) {\r",
									"          let parameterValue = loadParameterValue(parameter);\r",
									"          replacedPathName = replacedPathName.replace(match, parameterValue);\r",
									"          return false;\r",
									"        }\r",
									"      } else {\r",
									"        if (param.in && param.in.toLowerCase() == 'path' && param.name && param.name == paramName) {\r",
									"          let parameterValue = loadParameterValue(param);\r",
									"          replacedPathName = replacedPathName.replace(match, parameterValue);\r",
									"          return false;\r",
									"        }\r",
									"      }\r",
									"    });\r",
									"  });\r",
									"\r",
									"  console.log('Path after replacing:', replacedPathName);\r",
									"  return url.parse(replacedPathName);\r",
									"}\r",
									"\r",
									"function getSchemaReference(schema, referenceName) {\r",
									"  console.log('Getting schema reference for:', referenceName);\r",
									"\r",
									"  const refPieces = referenceName.split('/');\r",
									"  let reference = schema;\r",
									"  for (let i = 1; i < refPieces.length; i++) {\r",
									"    reference = reference[refPieces[i]];\r",
									"  }\r",
									"\r",
									"  console.log('Schema reference found:', reference);\r",
									"  return reference;\r",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"id": "76359d1b-ba73-471b-8859-822668aa5453",
								"exec": [
									"const schemaTests = JSON.parse(pm.collectionVariables.get('coll-schemaTests'));\r",
									"if(schemaTests.length > 0){\r",
									"    postman.setNextRequest('Test Request');\r",
									"}\r",
									"\r",
									"const schemaTest = JSON.parse(pm.variables.get('currentSchemaTest'));\r",
									"console.log(schemaTest.name);\r",
									"\r",
									"pm.test(`${schemaTest.name} - Has expected status code`, function () {\r",
									"    // const errorOn500 = pm.environment.get('env-errorOn500');\r",
									"    // if(errorOn500){\r",
									"    //   pm.response.to.not.have.status(500);\r",
									"    // }\r",
									"\r",
									"    if(schemaTest.success){\r",
									"        try{\r",
									"            if(pm.response.code >= 400) {\r",
									"                const jsonData = pm.response.json();\r",
									"                if(pm.response.code == 401)         {\r",
									"                  pm.expect(pm.request.headers.get('Role')).to.equal('role');\r",
									"                }\r",
									"                pm.expect('').to.equal(jsonData.message);                \r",
									"            }\r",
									"            \r",
									"            pm.expect(pm.response.code).to.not.equal(400);\r",
									"        }\r",
									"        catch(err) {\r",
									"            console.log(err);\r",
									"            pm.expect(pm.response.code).to.not.equal(400);\r",
									"        }        \r",
									"    }\r",
									"    else {\r",
									"        pm.response.to.have.status(400);\r",
									"    }    \r",
									"});\r",
									"\r",
									"const expectedResponse = schemaTest.responses.find(r => r.statusCode == pm.response.code);\r",
									"pm.test(`${schemaTest.name} - Status code (${pm.response.code}) is allowed`, function(){\r",
									"    pm.expect(expectedResponse).to.exist;\r",
									"});\r",
									"\r",
									"if(expectedResponse){\r",
									"    pm.test(`${schemaTest.name} - Has expected response body schema`, function(){\r",
									"        const Ajv = require('ajv');\r",
									"        const ajv = new Ajv({allErrors: true,format: false});\r",
									"        \r",
									"        if(pm.response.code == 204 || shouldResponseBeEmpty(expectedResponse)){\r",
									"            checkForEmptyResponse();\r",
									"        }\r",
									"        else if(expectedResponse.$ref){            \r",
									"            const jsonData = pm.response.json();\r",
									"            const schema = JSON.parse(pm.collectionVariables.get('coll-schema'));\r",
									"            ajv.addSchema(schema, 'OAS');\r",
									"            \r",
									"            const valid = ajv.validate({$ref: `OAS${expectedResponse.$ref}`}, jsonData);\r",
									"            const errors = ajv.errorsText(valid.errors);\r",
									"            pm.expect(errors).to.equal('No errors');\r",
									"            if(errors !== 'No errors'){\r",
									"                console.log(errors);\r",
									"            }\r",
									"        }\r",
									"        else if(expectedResponse.schema){\r",
									"            const jsonData = pm.response.json();\r",
									"            const validate = ajv.compile(expectedResponse.schema);\r",
									"            const valid = validate(jsonData);\r",
									"            const errors = ajv.errorsText(valid.errors);\r",
									"            pm.expect(errors).to.equal('No errors');\r",
									"            if(errors !== 'No errors'){\r",
									"                console.log(errors);\r",
									"            }\r",
									"        }\r",
									"        else {\r",
									"            checkForEmptyResponse();\r",
									"        }\r",
									"\r",
									"        if(expectedResponse.variables){\r",
									"            const jsonData = pm.response.json();\r",
									"            _.forEach(expectedResponse.variables, function(variable){\r",
									"                let pathPieces = variable.path.split('.').filter(piece => piece);\r",
									"                let data = jsonData;\r",
									"                let found = true;\r",
									"                _.forEach(pathPieces, function(piece){\r",
									"                    if(data[piece]){\r",
									"                        data = data[piece];\r",
									"                    }\r",
									"                    else {\r",
									"                        found = false;\r",
									"                    }\r",
									"                });\r",
									"\r",
									"                if(found){\r",
									"                    pm.collectionVariables.set(variable.name, data);\r",
									"                }\r",
									"                else {\r",
									"                    pm.test(`Unable to save dynamic variable ${variable.name} at the provided path.`, function() {\r",
									"                        pm.expect(true).to.equal(variable.path);\r",
									"                    });\r",
									"                }\r",
									"            });\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function checkForEmptyResponse() {\r",
									"    let emptyBody = true;\r",
									"    if(pm.response.text()){\r",
									"        emptyBody = false; \r",
									"    }\r",
									"\r",
									"    pm.expect(emptyBody).to.be.true;\r",
									"}\r",
									"\r",
									"function shouldResponseBeEmpty(expectedResponse){\r",
									"    let responseSchema = expectedResponse.schema;\r",
									"    if(expectedResponse.$ref){\r",
									"        let schema = JSON.parse(pm.collectionVariables.get('coll-schema'));\r",
									"        responseSchema = getSchemaReference(schema, expectedResponse.$ref);\r",
									"        if(expectedResponse.$ref.startsWith('#/components/responses')){\r",
									"            return (!responseSchema || !responseSchema.content || !responseSchema.content['application/json'] \r",
									"                || !responseSchema.content['application/json'].schema || Object.keys(responseSchema.content['application/json'].schema).length == 0);\r",
									"        } else {\r",
									"            return false;\r",
									"        }\r",
									"    }\r",
									"    else {\r",
									"        return (Object.keys(responseSchema).length == 0);\r",
									"    }\r",
									"}\r",
									"\r",
									"function getSchemaReference(schema, referenceName){  \r",
									"  const refPieces = referenceName.split('/');\r",
									"  let reference = schema;\r",
									"  for(let i = 1; i < refPieces.length; i++){\r",
									"    reference = reference[refPieces[i]];\r",
									"  }\r",
									"\r",
									"  return reference;  \r",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"id": "7b0e8dcd-2a73-4440-9e97-519060805fd5",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{body}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "https://postman-echo.com/get",
							"protocol": "https",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"get"
							]
						}
					},
					"response": []
				}
			],
			"id": "bfcd688b-381a-481b-b80d-31c260344011"
		},
		{
			"name": "Finalize",
			"item": [
				{
					"name": "More APIs to Process?",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"let apis = pm.collectionVariables.get('coll-apiIds');\r",
									"if(apis){\r",
									"    try{\r",
									"        apis = JSON.parse(apis);\r",
									"        if(apis.length > 0){\r",
									"            postman.setNextRequest('Get Current API Version');\r",
									"        }\r",
									"    }\r",
									"    catch(err){}    \r",
									"}"
								],
								"type": "text/javascript",
								"id": "1f04a156-d267-42a3-8c41-8ff925fa42ed"
							}
						}
					],
					"id": "bead0765-f9f4-42c0-a9c0-a88594eeedc5",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "https://postman-echo.com/delay/0",
							"protocol": "https",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"delay",
								"0"
							]
						}
					},
					"response": []
				},
				{
					"name": "Remove Test Variables",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// See https://blog.postman.com/2019/05/28/pro-tip-dynamically-unset-postman-environment-variables/\r",
									"// for more details on what we're doing here. \r",
									"\r",
									"cleanupCollectionVariables();\r",
									"\r",
									"function cleanupCollectionVariables() {\r",
									"    const clean = _.keys(pm.collectionVariables.toObject());\r",
									"\r",
									"    _.each(clean, (arrItem) => {\r",
									"        pm.collectionVariables.unset(arrItem);\r",
									"    });\r",
									"}"
								],
								"type": "text/javascript",
								"id": "670c8138-1c93-476a-b54a-a72271f9819d"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"id": "db2c94dc-614c-4f8d-adaf-2dcd1213c421"
							}
						}
					],
					"id": "3db81aee-aaeb-498c-bcbd-f3549290175c",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "https://postman-echo.com/delay/0",
							"protocol": "https",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"delay",
								"0"
							]
						}
					},
					"response": []
				}
			],
			"id": "fa4d000a-7a7f-4bbe-bdf0-4e0920ec087b"
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				],
				"id": "3e249f8b-8ef3-4c55-8258-478c37874e5b"
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				],
				"id": "32d28173-e9a0-4556-b4cc-92782900dcb5"
			}
		}
	],
	"variable": [
		{
			"id": "206e2973-10fc-422b-b7e9-00e25013cd1d",
			"key": "coll-apiIds",
			"value": ""
		},
		{
			"id": "c7712faf-5419-4aa3-9847-1cffcf5180bf",
			"key": "coll-apiId",
			"value": ""
		},
		{
			"id": "c0f0a17d-4771-41a3-be8d-7b641181d916",
			"key": "coll-versionId",
			"value": ""
		},
		{
			"id": "d994a18e-3d68-4a38-8a72-2227879e18a2",
			"key": "coll-schemaId",
			"value": ""
		},
		{
			"id": "8c736fc9-3dc2-4786-b081-a8a512d25c29",
			"key": "coll-schema",
			"value": ""
		},
		{
			"id": "00d8b0b3-0858-4a0a-a40c-3d99656c0012",
			"key": "coll-baseUrl",
			"value": ""
		},
		{
			"id": "5ca53fd9-c877-45f8-b682-cf976e86b439",
			"key": "coll-schemaTests",
			"value": ""
		}
	]
}